# ğŸš€ Dive Deep Into the Code

Welcomeee! We have completed setting up the basic structure of our app, right? Now, letâ€™s dig deep in!!

First, letâ€™s code the component which will handle the MetaMask connection and also it will connect our dApp with the smart contract enabling us to interact with the contract.

## ğŸ¦Š MetaMask Setup

Now, in the `App()` function, under the loading messages constants (`const`), we created in the last lesson paste these two `useEffects()`:

```javascript
// To intialize metamask and connect with the smart contract
useEffect(() => {
    if (started) {
	    if (window.ethereum) {
	      setConnected(true);
	      window.ethereum.on("accountsChanged", (accounts) => {
	        // update the connection status when the user changes accounts
	        setAccount(accounts[0]);
	        setConnected(true);
	      });
	      window.ethereum.on("disconnect", () => {
	        // update the connection status when the user disconnects
	        setAccount("");
	        setConnected(false);
	        setMinted(false); // Reset the minted state when the user disconnects
	      });
	      window.ethereum.enable().then((accounts) => {
	        setAccount(accounts[0]);
	        const hogwartsAddress = "Your Hogwarts NFT smart contract address goes here";
	        const randomHouseAddress = "Your Random House Assignment smart contract address goes here";
	
	      const hogwartsInstance = new web3.eth.Contract(
	        HogwartsNFT.abi,
	        hogwartsAddress
	      );
	      const randomHouseInstance = new web3.eth.Contract(
	        RandomHouseAssignment.abi,
	        randomHouseAddress
	      );
	
	      setHogwartsContract(hogwartsInstance);
	      setRandomHouseContract(randomHouseInstance);
	    
	      
	      checkMinted(); // Check for a minted NFT when the app first loads
	      });
	    } else {
	      alert("Please install MetaMask to use this app!");
	    }
	  }
  }, [started]);

//To check for account and start changes
  useEffect(() => {
    if (started) {
    if (hogwartsContract|| randomHouseContract || account) {
      checkMinted();
    }
  }
  }, [account, started]);
```

Now, let us explain what we did here.

### First `useEffect`: Initial Setup

The first `useEffect` does several things:

1. **Check If MetaMask Exists**: The code starts by checking if `window.ethereum` exists, which is essentially a way to see if MetaMask is installed.
    
    ```javascript
    if (window.ethereum) {
      setConnected(true);
    ```
    
    If MetaMask isn't installed, an alert prompts the user to install it.
    
    ```javascript
    } else {
      alert("Please install MetaMask to use this app!");
    }
    ```
    
2. **Listening for Account Changes**: The hook listens for the event `"accountsChanged"` to detect any change in the connected MetaMask account.
    
    ```javascript
    window.ethereum.on("accountsChanged", (accounts) => {
      setAccount(accounts[0]);
      setConnected(true);
    });
    ```
    
3. **Listening for Disconnects**: Similarly, the hook listens for the event `"disconnect"` to manage when a user disconnects their MetaMask account.
    
    ```javascript
    window.ethereum.on("disconnect", () => {
      setAccount("");
      setConnected(false);
      setMinted(false);
    });
    ```
    
4. **Initialize Smart Contracts**: If MetaMask is enabled and the accounts are accessible, the code initializes two smart contracts, `HogwartsNFT` and `RandomHouseAssignment`.
    1. Make sure to add your respective contract address :
        - For `hogwartsAddress`, replace â€œYour Hogwarts NFT smart contract address goes hereâ€ with the contract address of `HogwartsNFT.sol`.
        - For `randomHouseAddress`, replace â€œYour Random House Assignment smart contract address goes hereâ€ with the contract address of `RandomHouseAssignment.sol`.
    
    ```javascript
    window.ethereum.enable().then((accounts) => {
            setAccount(accounts[0]);
            const hogwartsAddress = "Your Hogwarts NFT smart contract address goes here";
            const randomHouseAddress = "Your Random House Assignment smart contract address goes here";
    
          const hogwartsInstance = new web3.eth.Contract(
            HogwartsNFT.abi,
            hogwartsAddress
          );
          const randomHouseInstance = new web3.eth.Contract(
            RandomHouseAssignment.abi,
            randomHouseAddress
          );
    ```
    
5. **Check Minted Status**: Finally, it invokes the `checkMinted()` function to see if an NFT has already been minted.
    
    ```javascript
    checkMinted();
    ```
    

### Second `useEffect`: Staying Updated

The second `useEffect` is much simpler. Its sole purpose is to keep the app updated.

1. **Re-check Minted Status**: This block re-invokes `checkMinted()` whenever the `account` or `started` state changes, ensuring that the app's status is updated accordingly.
    
    ```javascript
    useEffect(() => {
      if (started) {
        if (hogwartsContract || randomHouseContract || account) {
          checkMinted();
        }
      }
    }, [account, started]);
    ```
    

So summing it up, the first `useEffect` is all about setup and initial state, while the second `useEffect` ensures that the app remains current if something changes.

## âš™ï¸ Check if network is Arbitrium Sepolia or not

We will use the following code to check if the network our app is connected is Arbitrium Sepolia or not.

```javascript
useEffect(() => {
    if(started && window.ethereum) {
      checkNetwork();
      
      window.ethereum.on("networkChanged", checkNetwork);
      
      return () => {
        window.ethereum.removeListener("networkChanged", checkNetwork);
      }
    }
  }, [started]);

const checkNetwork = async () => {
    try {
      if (!window.ethereum) {
        alert("Please install MetaMask!");
        return;
      }

      const networkId = await window.ethereum.request({ method: 'net_version' });

      if(networkId === '421614') {
        setStarted(true);
        playBgSound(); 
        setResponseLoading(true);
        
        // Initialize Web3 and contracts after network check
        const web3Instance = new Web3(window.ethereum);
        const accounts = await web3Instance.eth.getAccounts();
        
        const hogwartsInstance = new web3Instance.eth.Contract(
          HogwartsNFTArtifact,
          HOGWARTS_CONTRACT_ADDRESS
        );
        
        const randomHouseInstance = new web3Instance.eth.Contract(
          RandomHouseAssignmentArtifact,
          RANDOM_HOUSE_CONTRACT_ADDRESS
        );

        setAccount(accounts[0]);
        setWeb3(web3Instance);
        setHogwartsContract(hogwartsInstance);
        setRandomHouseContract(randomHouseInstance);
        setConnected(true);
        
        // Check if user has already minted
        await checkMinted();
      } else {
        alert("Please connect to Arbitrum Sepolia Testnet"); 
      }
    } catch (error) {
      console.error("Error in checkNetwork:", error);
      alert("Error connecting to the network. Please make sure MetaMask is installed and connected.");
      setResponseLoading(false);
    }
  }
```

## âš™ï¸ Connect or disconnect wallet

Now, letâ€™s code how we can implement the logic to connect or disconnect the wallet:

```javascript
const disconnectMetamask = async () => {
    try {
      await window.ethereum.enable();
      setConnected(false);
      setAccount("");
      setHouse("");
      sethouseSlogan("");
      stopBgSound();
      setStarted(false);
      setIsUserNameSubmitted(false);
      setUserName("");
    } catch (err) {
      console.error(err);
    }
  };

  const connectMetamask = async () => {
    try {
      await window.ethereum.request({ method: "wallet_requestPermissions", params: [{ eth_accounts: {} }] });
      setConnected(true);
    } catch (err) {
      console.error(err);
    }
  };
```

In the `disconnectMetamask` function, the following line is trying to enable MetaMask.

```javascript
await window.ethereum.enable();
```

Immediately after, we reset several state variables.

```javascript
setConnected(false);
setAccount("");
//rest of the states
```

It also stops the background sound by calling the following function.

```javascript
stopBgSound();
```

Any errors during this process are caught and logged.

```javascript
catch (err) {
  console.error(err);
}
```

Switching to `connectMetamask`, the function begins by requesting permission from MetaMask.

```javascript
await window.ethereum.request({ method: "wallet_requestPermissions", params: [{ eth_accounts: {} }] });
```

If the request is successful, it sets the connected status to `true`.

```javascript
setConnected(true);
```

Just like the other function, errors are caught and logged.

```javascript
catch (err) {
  console.error(err);
}
```

Summing up, `disconnectMetamask` is about disconnecting and resetting, while `connectMetamask` is for establishing a new connection. Both handle errors gracefully.

## ğŸ¬ Wrap up

ğŸ‰ Boom! Weâ€™ve successfully integrated MetaMask and smart contract interaction. Now our dApp can:

Detect and handle MetaMask connection.

React to account and network changes.

Connect and disconnect seamlessly.

âœ¨ Next up: Minting Hogwarts NFTs & Sorting into Houses! Stay tuned! ğŸ°âš¡
