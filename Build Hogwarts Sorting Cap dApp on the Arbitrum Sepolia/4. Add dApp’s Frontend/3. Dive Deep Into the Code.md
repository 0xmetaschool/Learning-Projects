# 🚀 Dive Deep Into the Code

Welcomeee! We have completed setting up the basic structure of our app, right? Now, let’s dig deep in!!

First, let’s code the component which will handle the MetaMask connection and also it will connect our dApp with the smart contract enabling us to interact with the contract.

## 🦊 MetaMask Setup

Now, in the `App()` function, under the loading messages constants (`const`), we created in the last lesson paste these two `useEffects()`:

```javascript
// To intialize metamask and connect with the smart contract
useEffect(() => {
    if (started) {
	    if (window.ethereum) {
	      setConnected(true);
	      window.ethereum.on("accountsChanged", (accounts) => {
	        // update the connection status when the user changes accounts
	        setAccount(accounts[0]);
	        setConnected(true);
	      });
	      window.ethereum.on("disconnect", () => {
	        // update the connection status when the user disconnects
	        setAccount("");
	        setConnected(false);
	        setMinted(false); // Reset the minted state when the user disconnects
	      });
	      window.ethereum.enable().then((accounts) => {
	        setAccount(accounts[0]);
	        const hogwartsAddress = "Your Hogwarts NFT smart contract address goes here";
	        const randomHouseAddress = "Your Random House Assignment smart contract address goes here";
	
	      const hogwartsInstance = new web3.eth.Contract(
	        HogwartsNFT.abi,
	        hogwartsAddress
	      );
	      const randomHouseInstance = new web3.eth.Contract(
	        RandomHouseAssignment.abi,
	        randomHouseAddress
	      );
	
	      setHogwartsContract(hogwartsInstance);
	      setRandomHouseContract(randomHouseInstance);
	    
	      
	      checkMinted(); // Check for a minted NFT when the app first loads
	      });
	    } else {
	      alert("Please install MetaMask to use this app!");
	    }
	  }
  }, [started]);

//To check for account and start changes
  useEffect(() => {
    if (started) {
    if (hogwartsContract|| randomHouseContract || account) {
      checkMinted();
    }
  }
  }, [account, started]);
```

Now, let us explain what we did here.

### First `useEffect`: Initial Setup

The first `useEffect` does several things:

1. **Check If MetaMask Exists**: The code starts by checking if `window.ethereum` exists, which is essentially a way to see if MetaMask is installed.
    
    ```javascript
    if (window.ethereum) {
      setConnected(true);
    ```
    
    If MetaMask isn't installed, an alert prompts the user to install it.
    
    ```javascript
    } else {
      alert("Please install MetaMask to use this app!");
    }
    ```
    
2. **Listening for Account Changes**: The hook listens for the event `"accountsChanged"` to detect any change in the connected MetaMask account.
    
    ```javascript
    window.ethereum.on("accountsChanged", (accounts) => {
      setAccount(accounts[0]);
      setConnected(true);
    });
    ```
    
3. **Listening for Disconnects**: Similarly, the hook listens for the event `"disconnect"` to manage when a user disconnects their MetaMask account.
    
    ```javascript
    window.ethereum.on("disconnect", () => {
      setAccount("");
      setConnected(false);
      setMinted(false);
    });
    ```
    
4. **Initialize Smart Contracts**: If MetaMask is enabled and the accounts are accessible, the code initializes two smart contracts, `HogwartsNFT` and `RandomHouseAssignment`.
    1. Make sure to add your respective contract address :
        - For `hogwartsAddress`, replace “Your Hogwarts NFT smart contract address goes here” with the contract address of `HogwartsNFT.sol`.
        - For `randomHouseAddress`, replace “Your Random House Assignment smart contract address goes here” with the contract address of `RandomHouseAssignment.sol`.
    
    ```javascript
    window.ethereum.enable().then((accounts) => {
            setAccount(accounts[0]);
            const hogwartsAddress = "Your Hogwarts NFT smart contract address goes here";
            const randomHouseAddress = "Your Random House Assignment smart contract address goes here";
    
          const hogwartsInstance = new web3.eth.Contract(
            HogwartsNFT.abi,
            hogwartsAddress
          );
          const randomHouseInstance = new web3.eth.Contract(
            RandomHouseAssignment.abi,
            randomHouseAddress
          );
    ```
    
5. **Check Minted Status**: Finally, it invokes the `checkMinted()` function to see if an NFT has already been minted.
    
    ```javascript
    checkMinted();
    ```
    

### Second `useEffect`: Staying Updated

The second `useEffect` is much simpler. Its sole purpose is to keep the app updated.

1. **Re-check Minted Status**: This block re-invokes `checkMinted()` whenever the `account` or `started` state changes, ensuring that the app's status is updated accordingly.
    
    ```javascript
    useEffect(() => {
      if (started) {
        if (hogwartsContract || randomHouseContract || account) {
          checkMinted();
        }
      }
    }, [account, started]);
    ```
    

So summing it up, the first `useEffect` is all about setup and initial state, while the second `useEffect` ensures that the app remains current if something changes.

## ⚙️ Check if network is Arbitrium Sepolia or not

We will use the following code to check if the network our app is connected is Arbitrium Sepolia or not.

```javascript
useEffect(() => {
    if(started && window.ethereum) {
      checkNetwork();
      
      window.ethereum.on("networkChanged", checkNetwork);
      
      return () => {
        window.ethereum.removeListener("networkChanged", checkNetwork);
      }
    }
  }, [started]);

const checkNetwork = async () => {
    try {
      if (!window.ethereum) {
        alert("Please install MetaMask!");
        return;
      }

      const networkId = await window.ethereum.request({ method: 'net_version' });

      if(networkId === '421614') {
        setStarted(true);
        playBgSound(); 
        setResponseLoading(true);
        
        // Initialize Web3 and contracts after network check
        const web3Instance = new Web3(window.ethereum);
        const accounts = await web3Instance.eth.getAccounts();
        
        const hogwartsInstance = new web3Instance.eth.Contract(
          HogwartsNFTArtifact,
          HOGWARTS_CONTRACT_ADDRESS
        );
        
        const randomHouseInstance = new web3Instance.eth.Contract(
          RandomHouseAssignmentArtifact,
          RANDOM_HOUSE_CONTRACT_ADDRESS
        );

        setAccount(accounts[0]);
        setWeb3(web3Instance);
        setHogwartsContract(hogwartsInstance);
        setRandomHouseContract(randomHouseInstance);
        setConnected(true);
        
        // Check if user has already minted
        await checkMinted();
      } else {
        alert("Please connect to Arbitrum Sepolia Testnet"); 
      }
    } catch (error) {
      console.error("Error in checkNetwork:", error);
      alert("Error connecting to the network. Please make sure MetaMask is installed and connected.");
      setResponseLoading(false);
    }
  }
```

## ⚙️ Connect or disconnect wallet

Now, let’s code how we can implement the logic to connect or disconnect the wallet:

```javascript
const disconnectMetamask = async () => {
    try {
      await window.ethereum.enable();
      setConnected(false);
      setAccount("");
      setHouse("");
      sethouseSlogan("");
      stopBgSound();
      setStarted(false);
      setIsUserNameSubmitted(false);
      setUserName("");
    } catch (err) {
      console.error(err);
    }
  };

  const connectMetamask = async () => {
    try {
      await window.ethereum.request({ method: "wallet_requestPermissions", params: [{ eth_accounts: {} }] });
      setConnected(true);
    } catch (err) {
      console.error(err);
    }
  };
```

In the `disconnectMetamask` function, the following line is trying to enable MetaMask.

```javascript
await window.ethereum.enable();
```

Immediately after, we reset several state variables.

```javascript
setConnected(false);
setAccount("");
//rest of the states
```

It also stops the background sound by calling the following function.

```javascript
stopBgSound();
```

Any errors during this process are caught and logged.

```javascript
catch (err) {
  console.error(err);
}
```

Switching to `connectMetamask`, the function begins by requesting permission from MetaMask.

```javascript
await window.ethereum.request({ method: "wallet_requestPermissions", params: [{ eth_accounts: {} }] });
```

If the request is successful, it sets the connected status to `true`.

```javascript
setConnected(true);
```

Just like the other function, errors are caught and logged.

```javascript
catch (err) {
  console.error(err);
}
```

Summing up, `disconnectMetamask` is about disconnecting and resetting, while `connectMetamask` is for establishing a new connection. Both handle errors gracefully.

## 🎬 Wrap up

🎉 Boom! We’ve successfully integrated MetaMask and smart contract interaction. Now our dApp can:

Detect and handle MetaMask connection.

React to account and network changes.

Connect and disconnect seamlessly.

✨ Next up: Minting Hogwarts NFTs & Sorting into Houses! Stay tuned! 🏰⚡
