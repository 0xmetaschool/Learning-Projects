# 😺 The Ethereum Blockchain Paradigm

## Transactions and Messages ✉️

### Let's look at transactions and messages

We noted earlier that Ethereum is a transaction-based state machine. In other words, transactions occurring between different accounts are what move the global state of Ethereum from one state to the next.

In the most basic sense, a transaction is a cryptographically signed piece of instruction that is generated by an externally owned account, serialized, and then submitted to the blockchain.

There are two types of transactions: message calls and contract creations (i.e. transactions that create new Ethereum contracts).

**All transactions contain the following components, regardless of their type**:

-   nonce: a count of the number of transactions sent by the sender.
-   gasPrice: the number of Wei that the sender is willing to pay per unit of gas required to execute the transaction.
-   gasLimit: the maximum amount of gas that the sender is willing to pay for executing this transaction. This amount is set and paid upfront, before any computation is done.
-   to: the address of the recipient. In a contract-creating transaction, the contract account address does not yet exist, and so an empty value is used.
-   value: the amount of Wei to be transferred from the sender to the recipient. In a contract-creating transaction, this value serves as the starting balance within the newly created contract account.
-   v, r, s: used to generate the signature that identifies the sender of the transaction.
-   init (only exists for contract-creating transactions): An EVM code fragment that is used to initialize the new contract account. init is run only once, and then is discarded. When init is first run, it returns the body of the account code, which is the piece of code that is permanently associated with the contract account.
-   data (optional field that only exists for message calls): the input data (i.e. parameters) of the message call. For example, if a smart contract serves as a domain registration service, a call to that contract might expect input fields such as the domain and IP address.

![](https://lh3.googleusercontent.com/5uIyOrFTzePej053ke3XAvtCjDnriphcKGYmGFuGWDx1J9k406j0sr6SCRJCxSgLLT5t8rSQhSTTDG-O1mYjtxZ2gfRZ-BR2ZsYNTsl6PcusrZYfqwrgJrEtHXAnBnNiVdfX7ryd)

We learned in the “Accounts” section that transactions — both message calls and contract-creating transactions — are always initiated by externally owned accounts and submitted to the blockchain. Another way to think about it is that transactions are what bridge the external world to the internal state of Ethereum.

![](https://lh3.googleusercontent.com/FMUrWVSO4gq3XtwCQ7IuTkXNCFiqTXAk9HL6NqLwXU6t8EcGyzgPi1crehnbIrN8sf1cjKDTkl46gkq-bJRlEmYhRnhtxfBkvo9uEkcmhkTh9GKdz3o6WU5a5AaZwSO8luosRXvc)

But this doesn’t mean that contracts can’t talk to other contracts. Contracts that exist within the global scope of Ethereum’s state can talk to other contracts within that same scope. The way they do this is via “messages” or “internal transactions” to other contracts. We can think of messages or internal transactions as being similar to transactions, with the major difference that they are NOT generated by externally owned accounts. Instead, they are generated by contracts. They are virtual objects that, unlike transactions, are not serialized and only exist in the Ethereum execution environment.

When one contract sends an internal transaction to another contract, the associated code that exists on the recipient contract account is executed.

![](https://lh4.googleusercontent.com/aZVKdoQXlmdB6VYH5Qsz7-Fyl2AbT4phOayRrxbY0LRAXu7pVHTcb8zATzhPg_8nLgxtUuZtrYVw3y8McDzgwGMk1ilZpwAT-Pdum1SMlj6IAHqAs38iHCEeZXza7kshq4hMKijv)

One important thing to note is that internal transactions or messages don’t contain a gasLimit. This is because the gas limit is determined by the external creator of the original transaction (i.e. some externally owned account). The gas limit that the externally owned account sets must be high enough to carry out the transaction, including any sub-executions that occur as a result of that transaction, such as contract-to-contract messages. If, in the chain of transactions and messages, a particular message execution runs out of gas, then that message’s execution will revert, along with any subsequent messages triggered by the execution. However, the parent execution does not need to revert.